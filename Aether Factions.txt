/*
AETHER'S FACTION SYSTEM

Updated for TinyMUX and a non-Mistress-based system.

--> Aether's Factions Object <afo> created as object #2883

Requires the following user-defined functions:
	isstaff()	 - nothing new under the sun
	isfaction() - created in this very code
	header()	 - generic output header
	footer()	 - generic output footer
	isapproved() - does what it says on the tin
	pmatch()	 - this one might slip in there, so watch out for it

Requires the following considerations:
	create() 	 - must be wiz-okay

Stores on the Player:
	_faction-member: <X>!<#dbref>|...
	X: H if ooc administrator, N if normal member, either/or

Stores on the Faction Object:
	d_created-by: dbref of the staffer who created the faction
	information: if exists, a summary of the faction, set by faction heads
	member-<dbref>[-<rank>]: <dbref>[/<title>]


================================================================================
== Setup =======================================================================

@create Aether Faction Object <afo>
@fo me=&d.afo me=[search( name=Aether Faction Object <afo> )]
@set Aether Faction Object <afo>=INHERIT SAFE

@fo me=@parent Aether Faction Object <afo>=
	[search( name=Code Object Data Parent <codp> )]

&.msg [v( d.afo )]=ansi( h, <%0>, n, %b%1 )

/*
Include the following if you allow Wizards access to @function:

@Startup [v( d.afo )]=@function/preserve/privileged isfaction?=%!/f.isfaction?

@trig [v( d.afo )]/startup

*/



================================================================================
== Pseudo-Mistress Set-Up ======================================================

Calls:
	c.<name>.default: When '+<name>' is typed
	c.<name>.specific: When '+<name> <more>' is typed
	c.<name>/<switch>: When '+<name>/<switch> [<more>]' is typed

0: All input
n: Name of the command for finding 'c.<name>.default', et al. ( portability )

*/

&c.faction [v( d.afo )]=$^\+?factions?([^ ]*)$:@pemit %#=
	[setq( n, faction )]
	[switch( %1, 
// Without 's' ending
		, u( c.%qn.default ), 
		/*, u( c.%qn.switch, first( %1 ), rest( %1 )), 
		%b*, u( c.%qn.specific, trim( %1 )), 

// With 's' ending
		s, u( c.%qn.default ), 
		s/*, u( c.%qn.switch, /[first( after( %1, / ))], rest( %1 )), 
		s%b*, u( c.%qn.specific, trim( rest( %1 ))), 

// No match
		u( .msg, faction, 
			I don't know what you mean. 
			Please see: [ansi( h, +help %qn )] 
		)
	)]

// --

@set afo/c.faction=regexp

/*
--------------------------------------------------------------------------------
-- c.faction.switch ------------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and 
passes them on.

0: /<switch>
1: [<more>], stuff to pass to c.<name>/<switch>, if any
qn: Name of the command, global register set in &c.<name> ( above )
*/

&c.faction.switch [v( d.afo )]=
	udefault( 
		first( sort( lattr( %!/c.%qn*%0* ))), 
		u( .msg, secure( %qn ), No such switch ), 
		%1 
	)


/*
--------------------------------------------------------------------------------
-- c.faction.default -----------------------------------------------------------

faction -> faction/list
*/

&c.faction.default [v( d.afo )]=u( c.faction/list )


/*
--------------------------------------------------------------------------------
-- c.faction.specific ----------------------------------------------------------

Set it up so that you're searching for any word in a multi-word faction i.e., A 
faction named 'Jane's House of Horrors' will match on 'Jane', 'House', 'Horrors' 
or even 'Of'. 'grab' always grabs the FIRST match. Does partial name matches, 
too. So 'faction hou' might get it, too. 

Warning: This MAY be the only function that has 'middle name matching' on 
factions. If you want the long story as to the confusion, it's long. In general, 
assume only where you're sure you can fix a problem.

0: faction name

q0: List of ' <name>:<dbref>|...' that the user can-see
q1: Single matching '<name>:<dbref>'
uses: isstaff(), isfaction?()

*/

&c.faction.specific [v( d.afo )]=

// The Partial/In-Name Match
	[setq( 0, 
		iter( 
			filter( fil.see-faction, lcon( %! ), , , %# ), 
			%b[name( %i0 )]:%i0, 
			, |
		)
	)]
	[setq( 1, trim( grab( %q0, * %0*:*, | )))]

	[case( 0, 
		t( %q1 ), I can't find any faction by that name., 
		u( f.display.roster, last( %q1, : ))
	)]



/*
================================================================================
== faction/create ==============================================================

Creates an object within the faction code object that stores all the faction 
information. Removing a faction is simply deleting the object. Making a faction 
secret is simply setting it dark.

Creating a faction may *only* be done by a Wizard.

--

0: <name>[ = <faction head>]

qn: name of faction
qh: 1 if trying to set a faction head, 0 otherwise
qc: character dbref of initial faction head
qo: dbref of created faction object

*/

&c.faction/create [v( d.afo )]=
	[setq( n, trim( before( %0, = )))]
	[setq( h, comp( trim( after( %0, = )), ))]
	[setq( c, pmatch( trim( after( %0, = ))))]

	[case( 0, 

		isstaff( %# ), 
		u( .msg, faction, You can't create factions ), 

		or( not( %qh ), isdbref( %qc )), 
		u( .msg, faction, That player does not exist ), 

		or( not( %qh ), isapproved( %qc, approved )), 
		u( .msg, faction, That player is not approved ), 

		valid( %qn, thingname ), 
		u( .msg, faction, That's not a good name for a faction ), 

		not( isdbref( num( %qn ))), 
		u( .msg, faction, 
			A faction already exists with that name%, or close 
		), 

// No Errors: Make That Faction
		[setq( o, create( %qn, 10 ))]
		[set( %qo, d_created-by:%# )]

// .. did you try to make a faction head?
		[if( %qh, 
// .. .. yes
			[set( %qc, 
				_faction-member:[setunion( H!%qo, u( %qc/_faction-member ), | )] 
			)]
			[u( f.member.add, %qc, %qo )]
			[u( .msg, faction, 
				Faction '%qn' created with faction head [name( %qc )] 
			)], 
// .. .. no
			u( .msg, faction, 
				Faction '%qn' created without a faction head 
			)
		)]
	)]



/*
================================================================================
== faction/destroy =============================================================

Clears everyone from the faction and destroys it. Staff-only.

If the output looks odd, because some rosters are too large for the lbuf to 
handle, but list() avoids the output queue altogether. So to get the timing 
right, each output element is wrapped in a list().

--

0: <faction name>[=YES]

f: faction dbref
y: true if =YES was entered
l: list of members

d: attribute list
r: rank, if any
t: title, if any

*/

&c.faction/destroy [v( d.afo )]=
	[setq( f, num( trim( first( %0, = ))))]
	[setq( y, not( comp( rest( %0, = ), YES )))]

	[case( 0, 
		isstaff( %# ), 
		u( .msg, faction/destroy, Staff only. ), 

		isdbref( %qf ), 
		u( .msg, faction/destroy, Could not find that faction. ), 
		
		not( hasflag( %qf, going )), 
		u( .msg, faction/destroy, Faction is already destroyed ), 

		%qy, 
		u( .msg, faction/destroy, 
			If you're absolutely sure%, type: faction/destroy [name( %qf )]=YES 
		), 

		[setq( l, u( f.faction.roster, %qf ))]

// >> header
		[list( 1, 
			header( faction/destroy: [name( %qf )] ( %qf ))
		)]

// >> roster
		[list( %ql, 
			[setq( d, first( lattr( %qf/member-%i0* )))]
			[setq( r, extract( %qd, 3, 1, - ))]
			[setq( t, rest( get( %qf/%qd ), / ))]

// .. report
			%b [name( %i0 )] - 
			Title: [if( t( %qt ), %qt, none )] - 
			Rank: [if( t( %qt ), %qr, none )]
// .. remove character
			[u( f.member.remove, %i0, %qf )]
		)]

// >> footer
		[list( 1, 
			%b Information: [udefault( %qf/information, ( Not Set ))]%r %r
			%b Created By: [name( get( %qf/d_created-by ))] ( [get( %qf/d_created-by )] )%r
			[footer( [words( %ql )] members removed )]
			[destroy( %qf )]
		)]
	)]



/*
================================================================================
== faction/undestroy ==========================================================

Because the factions are objects, they will be marked 'going' until the system cleanup kicks in. Unset the 'going' flag.

NOTE TO SELF: locate() is better than num(), as you control where you look

0: <faction name>

f: faction dbref
e: possible error from 'set'

*/

&c.faction/undestroy [v( d.afo )]=
	[setq( f, locate( %!, %0, i ))]

	[case( 0, 
		isstaff( %# ), 
		u( .msg, faction/undestroy, Staff only ), 

		comp( %qf, #-1 ), 
		u( .msg, faction/undestroy, Could not find that faction ), 

		comp( %qf, #-2 ), 
		u( .msg, faction/undestroy, Too many factions matched ), 

		hasflag( %qf, GOING ), 
		u( .msg, faction/undestroy, 
			Faction '[name( %qf )]' is not being destroyed 
		), 

// set !going, check for error
		[not( strlen( setr( e, set( %qf, !GOING ))))], 
		u( .msg, faction/undestroy, !Going Failed: %qe ), 

		u( .msg, faction/undestroy, [name( %qf )] saved from deletion )
	)]		



/*
================================================================================
== faction/list ================================================================

New with headers for faction types.

qf: factions %# can see
qt: list|of|faction|types

*/

&c.faction/list [v( d.afo )]=
	[setq( f, filter( fil.see-faction, lcon( %! ), , , %# ))]
	[setq( t, setunion( lcstr( iter( %qf, get( %i0/d_type ), , | )), , | ))]

	[header( Factions )]%r

	[case( 0, 
// .. no factions visible
		words( %qf ), %b ( No factions to display ), 

// .. no faction types, display all by alpha sort
		words( %qt, | ), 
		u( f.display.one-faction-group, %qf ), 

// .. faction types, display one at a time starting with 'no type'
		iter( %qt, 
			[divider( if( comp( %i0, ), lcstr( %i0 ), ( no type )))]%r
			[u( f.display.one-faction-group, 
				filter( fil.faction-type, %qf, , , %i0 )
			)], 
			|, @@
		)

	)]%r

	[footer( words( %qf ))]


/*
--------------------------------------------------------------------------------
-- Display: One Faction Group --------------------------------------------------

0: list of faction objects ( by dbref )
ql: list of factions to show

*/

&f.display.one-faction-group [v( d.afo )]=
	[setq( l, 
		iter( sortby( f.sortby.object-name, %0 ), 
			[if( hasflag( %i0, DARK ), 
				ansi( xh, %[ [name( %i0 )] %] ), 
				name( %i0 )
			)], 
			, |
		)
	)]

	[columns( %ql, 38, |, 2 )]


/*
--------------------------------------------------------------------------------
-- Sortby: Object Name ---------------------------------------------------------
*/

&f.sortby.object-name [v( d.afo )]=comp( name( %0 ), name( %1 ))


/*
--------------------------------------------------------------------------------
-- Filter: Faction Type --------------------------------------------------------
*/

&fil.faction-type [v( d.afo )]=strmatch( get( %0/d_type ), %1 )


/*
================================================================================
== Display: Roster =============================================================

If the use of list() here looks odd, it's because list() skips the queue. By forcing all output into list(), it's processed in the proper order.

--

0: roster dbref

qp: player dbref
qr: rank, if any
qt: title, if any
qs: permissions list

*/

&f.display.roster [v( d.afo )]=
	[list( 1, 
		[header( [name( %0 )][if( isstaff( %# ), %b%( %0% ))] )]%r
		%b [ljust( Name, 25 )] [ljust( Title, 45 )] Rank%r
		%b[ansi( g, repeat( -, 77 ))]
	)]

// >> each line, sorted by rank
	[list( 
		setr( m, sortby( f.sortby.rank, lattr( %0/member-* ))), 
		[setq( p, extract( %i0, 2, 1, - ))]
		[setq( r, extract( %i0, 3, 1, - ))]
		[setq( t, after( get( %0/%i0 ), / ))]

		[if( u( f.factionhead?, %qp, %0 ), >, %b )] 
		[ljust( name( %qp ), 25 )] 
		[ljust( %qt, 45 )] 
		[center( %qr, 4 )]
	)]

	[list( 1, 
// >> info
		%b[ansi( g, repeat( -, 77 ))]%r

		[wrap( 
			udefault( %0/information, No Information Set. ), 
			76, , %b%b
		)]%r

// >> report who can see, if faction dark, has permissions, & facthead/staff
		[if( 
			and( 
				t( setr( s, get( %0/d_view-permission ))), 
				cor( 
					t( match( get( %#/_faction-member ), ?!%0, | )), 
					isstaff( %# )
				), 
// 				u( f.factionhead?, %#, %0 ), 
				or( isstaff( %# ), hasflag( %0, dark ))
			 ), 
		
			%b[ansi( g, repeat( -, 77 ))]%r

			[setq( s, 
				iter( %qs, 
					switch( %i0, 
						faction:*, Faction is [titlestr( rest( %i0, : ))], 
						sphere:*, Sphere is [titlestr( rest( %i0, : ))], 
						attribute:*:*, 
							Attribute '[lcstr( elements( %i0, 2, : ))]' 
							is set to '[lcstr( last( %i0, : ))]', 
						attribute:*, 
							Attribute '[lcstr( rest( %i0, : ))]' exists, 
						Unknown permission '[lcstr( first( %i0, : ))]'
					 ), 
					|, |
				)
			)]

			%b View Permissions
			[if( not( hasflag( %0, dark )), %b[ansi( xh, %(if set dark%) )] )]:
			[itemize( %qs, | )]%r
		)]

// >> footer
		[footer( [words( %qm )] members )]

	)]


/*
--------------------------------------------------------------------------------
-- Function: Faction Roster ----------------------------------------------------

List of dbrefs on the faction object as members.

0: faction dbref
*/

&f.faction.roster [v( d.afo )]=
	iter( 
		sortby( f.sortby.rank, lattr( %0/member-* )), 
		extract( %i0, 2, 1, - )
	)


/*
--------------------------------------------------------------------------------
-- Function: Sort by Rank ------------------------------------------------------

0: List Of Attributes (probably should be surrounded in a localize())
*/

&f.sortby.rank [v( d.afo )]=
	[setq( 0, last( %0, - ))]
	[setq( 1, last( %1, - ))]
	[case( 1, 
		gt( %q0, %q1 ), -1, 
		eq( %q0, %q1 ), 0, 
		lt( %q0, %q1 ), 1
	)]



/*
================================================================================
== faction/add =================================================================

Add someone to a faction. ( Only faction heads and staff may do this, so there's 
no reason to check "see faction". )

0: <charname>=<faction name>

f: faction dbref
c: character dbref
// t: title - optional with rank - not used at the moment
// r: rank - optional with title - not used at the moment

a: faction head/staff?

*/

&c.faction/add [v( d.afo )]=
	[setq( f, num( trim( first( first( %0, / ), = ))))]
	[setq( c, pmatch( trim( rest( %0, = ))))]
// 	[setq( f, num( trim( rest( %0, = ))))]
// 	[setq( c, pmatch( trim( first( first( %0, / ), = ))))]
// 	[setq( t, extract( %qc, 2, 1, / ))]
 	[setq( r, )]

	[case( 0, 
		t( %qf ), 
		u( .msg, faction/add, That faction does not exist ), 

		u( f.factionhead?, %#, %qf ), 
		u( .msg, faction/add, You are not a faction head for this faction ), 

		t( %qc ), 
		u( .msg, faction/add, Name specified is not a player ), 

		isapproved( %qc, approved ), 
		u( .msg, faction/add, Player is not approved ), 

		not( hasflag( %qf, going )), 
		u( .msg, faction/add, 
			Faction has been deleted and is waiting to be cleared 
			from the system 
		), 

		not( match( get( %qc/_faction-member ), ?!%qf, | )), 
		u( .msg, faction/add, Player is already a member of that faction ), 

// 		if( t( %qr ), isint( %qr ), 1 ), 
// 		u( .msg, faction/add, Rank must be numeric ), 

// >> okay
// .. add member to function object and to member object
		[u( f.member.add, %qc, %qf, %qr, %qt )]
		[u( .msg, faction/add, [name( %qc )] added to faction '[name( %qf )]' )]
	)]


/*
--------------------------------------------------------------------------------
-- Function: Add Member (to Faction) -------------------------------------------

A simple function to add someone, and details, to a specific faction. Won't set rank without faction and visa versa. Won't set on a dbref that's not a faction.

Use this for adding or removing someone whose rank/title is being changed, too, by deleting the attribute and re-adding it.

			member-<#dbref>[-<rank>]: <#dbref>[/<title>]

0: dbref of member
1: dbref of faction
2: rank, optional ( to erase, pass '-' )
3: title, optional ( to erase, pass '-' )

qo: original attribute name
qn: new attribute name
qc: new attribute contents

*/

&f.member.add [v( d.afo )]=
	localize( 


// >> qn: Name of the attribute we'll be setting on the Faction Object
		[setq( o, first( lattr( %1/member-%0* )))]
		[setq( n, 
			case( 1, 
// .. if rank is '-', remove it
				strmatch( %2, - ), member-%0, 
// .. if other rank passed, override original rank
				t( %2 ), member-%0-%2, 
// .. else if an attribute already exists, use that
				t( %qo ), %qo, 
// .. else create a new, empty attribute
				member-%0
			)
		)]

// >> qc: Contents of the attribute we'll be setting on the Faction Object
		[setq( c, 
			case( 1, 
// .. if title is '-', remove it
				strmatch( %3, - ), %0, 
// .. else if a title passed, override original title
				t( %3 ), %0/%3, 
// .. else if something exists, use that, else use %0
				default( %1/%qo, %0 )
			)
		)]

// >> Don't set anything if %1 isn't a Faction Object
		[case( 1, 

			t( setinter( lcon( %! ), %1 )), 

// .. remove any existing attribute and add the new one, built above
			[if( t( %qo ), set( %1, %qo: ))][set( %1, %qn:%qc )]
// .. add Faction to Player Object if they don't already have it
			[if( 
				not( t( match( get( %0/_faction-member ), ?!%1, | ))), 
				set( 
					%0, 
					_faction-member:
					[setunion( get( %0/_faction-member ), N!%1, | )]
				)
			)], 

			#-2
		)]
	)



/*
================================================================================
== faction/remove ==============================================================

0: <person>=<faction name>

qf: faction dbref
qc: dbref - prefer character, but try everything
*/

&c.faction/remove [v( d.afo )]=
	[setq( f, num( trim( before( %0, = ))))]
	[setq( c, pmatch( trim( rest( %0, = ))))]
	[setq( c, case( 1, t( %qc ), %qc, locate( %!, trim( rest( %0, = )), *P )))]

	[case( 0, 
		isdbref( %qf ), 
		u( .msg, faction/remove, Faction name does not exist ), 

		isdbref( %qc ), 
		u( .msg, faction/remove, Could not find target ), 

		u( f.factionhead?, %#, %qf ), 
		u( .msg, faction/remove, You are not a faction head for that faction ), 

// .. only staff may remove a member who is a faction head
		or( 
			not( u( f.factionhead?, %qc, %qf )), 
			isstaff( %# )
		 ), 
		u( .msg, faction/remove, 
			You cannot remove faction heads. Please ask staff 
		), 

		t( lattr( %qf/member-%qc* )), 
		u( .msg, faction/remove, Target is not part of the faction ), 

// >> okay
		[u( f.member.remove, %qc, %qf )]
		[name( %qc )] has been removed from [name( %qf )].
	)]


/*
--------------------------------------------------------------------------------
-- Function: Remove Member (from Faction) --------------------------------------

A simple function to add someone, and details, to a specific faction. Won't set 
on a dbref that's not a faction.

0: dbref of member
1: dbref of faction

g: grab the matching -- member attribute, then N!#dbref or H!#dbref

*/

&f.member.remove [v( d.afo )]=
	case( 1, 
		t( setinter( lcon( %! ), %1 )), 

// >> Remove from Faction Object
// 		[setq( g, lattr( %1/member-%0* ))]
		[setq( g, regrabi( lattr( %1/member-%0* ), member-%0( -.* )? ))]
		[set( %1, %qg: )]
		
// >> Remove Faction to Player Object
		[setq( g, grab( get( %0/_faction-member ), ?!%1, | ))]
		[set( %0, 
			_faction-member:[remove( get( %0/_faction-member ), %qg, | )] 
		)], 
		#-2
	)



/*
================================================================================
== faction/information =========================================================

Add or change information about the faction. ( Only faction heads and staff may do this, so there's no reason to check "see faction". )

0: <faction>=[<text>]

f: faction dbref
t: text, if any ( if none, clear )

*/

&c.faction/information [v( d.afo )]=
	[setq( f, num( trim( before( %0, = ))))]
	[setq( t, trim( rest( %0, = )))]

	[case( 0, 

		u( f.factionhead?, %#, %qf ), 
		u( .msg, faction/info, You are not a faction head for this faction ), 

		[set( %qf, information:%qt )]
		[u( .msg, faction/info, 
			The information paragraph for your faction has been recorded 
		)] 
	)]



/*
================================================================================
== faction/addhead =============================================================

Adds an OOC administrator for the faction

0: <person>=<faction name>

qf: faction dbref
qc: character dbref

*/

&c.faction/addhead [v( d.afo )]=
	[setq( f, num( trim( rest( %0, = ))))]
	[setq( c, pmatch( trim( before( %0, = ))))]

	[case( 0, 

		isstaff( %# ), 
		u( .msg, faction/addhead, Only staff may add faction heads ), 

		isdbref( %qf ), 
		u( .msg, faction/addhead, Faction name does not exist ), 

		isdbref( %qc ), 
		u( .msg, faction/addhead, Could not find player ), 

		isapproved( %qc, approved ), 
		u( .msg, faction/addhead, Player not approved ), 

		not( t( match( get( %qc/_faction-member ), H!%qf, | ))), 
		u( .msg, faction, Player is already a faction head ), 

// >> okay
// .. remove N! and add H! -- player doesn't need to be a member first
		[set( %qc, _faction-member:
			[setunion( 
				remove( u( %qc/_faction-member ), N!%qf, | ), 
				H!%qf, 
				|
			)]
		)]
		[u( .msg, faction/addhead, 
			[name( %qc )] has been added to the list of heads 
			for '[name( %qf )]' 
		)]
	)]



/*
================================================================================
== faction/removehead ==========================================================

Remove someone from the leadership and OOC administration of a particular 
faction.

0: <person>=<faction name>

qf: faction dbref
qc: character dbref

*/

&c.faction/removehead [v( d.afo )]=
	[setq( f, num( trim( rest( %0, = ))))]
	[setq( c, pmatch( trim( before( %0, = ))))]

	[case( 0, 

		isstaff( %# ), 
		u( .msg, faction/removehead, Only staff may remove faction heads ), 

		isdbref( %qf ), 
		u( .msg, faction/removehead, Faction name does not exist ), 

		isdbref( %qc ), 
		u( .msg, faction/removehead, Could not find player ), 
		
		t( match( get( %qc/_faction-member ), H!%qf, | )), 
		u( .msg, faction/removehead, Player is not a faction head ), 

// >> okay
// .. remove H! and add N! -- player doesn't need to be a member first
		[set( %qc, _faction-member:
			[setunion( 
				remove( u( %qc/_faction-member ), H!%qf, | ), 
				N!%qf, 
				|
			)]
		)]
		[u( .msg, faction/removehead, 
			[name( %qc )] has been removed from the list of heads 
			for '[name( %qf )]' 
		)]
	)]



/*
================================================================================
== faction/[!]dark ============================================================

Set a faction dark, or unset its darkness.

0: <faction name>
qf: faction dbref

*/

&c.faction/dark [v( d.afo )]=
	[setq( f, num( trim( %0 )))]

	[case( 0, 
		isstaff( %# ), 
		u( .msg, faction/dark, Staff only ), 

		isdbref( %qf ), 
		u( .msg, faction/dark, Faction not found ), 

		[set( %qf, dark )]
		[u( .msg, faction/dark, 
			Faction '[name( %qf )]' is set dark and may now only be seen 
			by staff and members
		)]
	)]

// --

&c.faction/!dark [v( d.afo )]=
	[setq( f, num( trim( %0 )))]

	[case( 0, 
		isstaff( %# ), 
		u( .msg, faction/!dark, Staff only ), 

		isdbref( %qf ), 
		u( .msg, faction/!dark, Faction not found ), 

		[set( %qf, !dark )]
		[u( .msg, faction/!dark, 
			Faction '[name( %qf )]' is set un-dark and may be seen 
			by all players 
		)]
	)]



/*
================================================================================
== faction/who =================================================================

aka fwho

0: optional faction name

qf: faction dbref
ql: list of visible people in that faction

*/

&c.faction/who [v( d.afo )]=
// >> find which faction you're a part of - first one if multiple
	[setq( f, 
		ifelse( 
			strmatch( %0, ), 
			before( after( u( %#/_faction-member ), ! ), | ), 
			locate( me, %0, i )
		)
	)]

// >> list of visible targets
// .. could be a filter(), feeling lazy
	[setq( l, 
		iter( 
			lattr( %qf/member-* ), 
			[setq( p, extract( %i0, 2, 1, - ))]
			[if( 
				and( 
					hasflag( %qp, connected ), 
					or( orflags( %qp, !D ), isstaff( %# ))
				 ), 
				%qp
			)]
		)
	)]

	[case( 0, 
		isdbref( %qf ), 
		u( .msg, faction, No faction by that name ), 

		u( fil.see-faction, %qf, %# ), 
		u( .msg, faction, No faction by that name ), 

		u( f.display.list-who, %qf, sortby( f.sortby.object-name, %ql ))
	)]



/*
================================================================================
== faction/whoall ==============================================================

aka fwho/all

*/

&c.fwho [v( d.afo )]=$^\+?fwho(.*)$:@pemit %#=
	[switch( %1, 
		/a*, u( c.faction/whoall, trim( rest( %0 ))), 
		u( c.faction/who, trim( %0 ))
	)]

@set v( d.afo )/c.fwho=regexp

// -- 

&c.faction/whoall [v( d.afo )]=
// >> find which faction you're a part of - first one if multiple
	[setq( f, 
		ifelse( 
			strmatch( %0, ), 
			before( after( u( %#/_faction-member ), ! ), | ), 
			locate( me, %0, i )
		)
	)]

// >> list of visible targets
// .. could be a filter(), feeling lazy
	[setq( l, 
		iter( 
			lattr( %qf/member-* ), 
			extract( %i0, 2, 1, - )
		)
	)]

	[case( 0, 
		isdbref( %qf ), 
		u( .msg, faction, No faction by that name ), 

		u( fil.see-faction, %qf, %# ), 
		u( .msg, faction, You cannot see that faction ), 

		u( f.display.list-who, %qf, %ql )
	)]


/*
--------------------------------------------------------------------------------
-- Display: List Who -----------------------------------------------------------

The fwho display.

0: dbref of faction
1: list of people to display

*/

&f.display.list-who [v( d.afo )]=

	[list( %1, 
// .. because we're using list(), on the first line throw the header

		[if( eq( #@, 1 ), 
			[header( faction/who: [name( %0 )] )]%r
			%b [ljust( Name, 14 )] [ljust( Alias, 5 )] 
			[ljust( Sex, 3 )] [ljust( Idle, 4 )] Location%r
			%b[ansi( g, repeat( -, 77 ))]%r
		)]

// .. one line
		[if( u( f.factionhead?, %i0, %0 ), >, %b )] 

		[ljust( name( %i0 ), 14 )] 
		[ljust( u( %i0/alias ), 5 )] 
		[ljust( lcstr( strtrunc( u( %i0/sex ), 1 )), 3 )] 
		[ljust( singletime( idle( %i0 )), 4 )] 
		[case( 1, 
			not( hasflag( %i0, connected )), 
			Not Connected, 

			strmatch( objeval( %#, loc( %i0 )), #-1 ), 
			Unfindable, 

			or( orflags( %i0, !D ), isstaff( %# )), 
			strtrunc( name( loc( %i0 )), 45 ), 

// .. report 'not connected' for people who are dark, except to staff
			Not Connected
		)]
	)]

	[if( not( words( %1 )), 
		[header( faction/who: [name( %0 )] )]%r%b No members connected.%r 
	)]
	[footer()]



/*
================================================================================
== faction/rank ================================================================

The original version of this function also listed rank as a kind of 
abbreviated fwho, but we have 'faction <name>' doing that already, 
so I'm skipping it.

0: <player>=<faction>[/<newrank>]

qf: faction dbref
qc: character dbref
qr: rank to be set
qo: old rank ( for reporting purposes )

*/

&c.faction/rank [v( d.afo )]=
	[setq( c, pmatch( trim( before( %0, = ))))]
	[setq( f, num( trim( before( rest( %0, = ), / ))))]
	[setq( r, if( t( setr( r, trim( rest( %0, / )))), %qr, - ))]

	[case( 0, 
		isdbref( %qf ), u( .msg, faction, Faction not found ), 

		isdbref( %qc ), u( .msg, faction, Player not found ), 

		u( f.factionhead?, %#, %qf ), 
		u( .msg, faction, You are not a faction head for this faction ), 

		t( match( get( %qc/_faction-member ), ?!%qf, | )), 
		u( .msg, faction, Player is not a member of that faction ), 

		or( and( isint( %qr ), gte( %qr, 0 )), strmatch( %qr, - )), 
		u( .msg, faction, Rank must be positive numeric or cleared ), 

// >> Okay
		[setq( o, extract( first( lattr( %qf/member-%qc* )), 3, 1, - ))]
		[u( f.member.add, %qc, %qf, %qr )]
		[u( .msg, faction, 
			Changed [name( %qc )]'s rank from '[if( t( %qo ), %qo, <none> )]' 
			to '[if( comp( %qr, - ), %qr, <none> )]'
		)]
	)]



/*
================================================================================
== faction/title ===============================================================

faction/title <faction>=<player>/<newtitle>

0: <player>=<faction>[/<newtitle>]

qf: faction dbref
qc: character dbref
qt: title to be set
qo: old title ( for reporting purposes )

*/

&c.faction/title [v( d.afo )]=
	[setq( c, pmatch( trim( before( %0, = ))))]
	[setq( f, num( trim( before( rest( %0, = ), / ))))]
	[setq( t, if( t( setr( t, trim( rest( %0, / )))), %qt, - ))]

	[case( 0, 
		isdbref( %qf ), u( .msg, faction, Faction not found ), 

		isdbref( %qc ), u( .msg, faction, Player not found ), 

		u( f.factionhead?, %#, %qf ), 
		u( .msg, faction, You are not a faction head for this faction ), 

		t( match( get( %qc/_faction-member ), ?!%qf, | )), 
		u( .msg, faction, Player is not a member of that faction ), 

// >> Okay
		[setq( o, rest( get( %qf/[first( lattr( %qf/member-%qc* ))] ), / ))]
		[u( f.member.add, %qc, %qf, , %qt )]
		[u( .msg, faction, 
			Changed [name( %qc )]'s title from '[if( t( %qo ), %qo, <none> )]' 
			to '[if( t( comp( %qt, - )), %qt, <none> )]'
		)]
	)]



/*
================================================================================
== faction/type ================================================================

What type of faction is this? Added specficially for Motley/Pack/etc. notifiers. 
Would it have been better if I made this "tags"? Time may tell.

0: <faction>[=<type>]

qf: faction dbref
qt: type
qo: old type, if any

*/

&c.faction/type [v( d.afo )]=
	[setq( f, num( trim( before( %0, = ))))]
	[setq( t, trim( after( %0, = )))]

	[case( 0, 
		isdbref( %qf ), u( .msg, faction, Faction not found ), 

		isstaff( %# ), u( .msg, faction, Only staff may set the faction type ), 

// >> Okay

		[setq( o, get( %qf/d_type ))]
		[set( %qf, d_type:%qt )]
		[u( .msg, faction, 
			Changed [name( %qf )] type from '[if( t( %qo ), %qo, <none> )]' 
			to '[if( t( t( %qt )), %qt, <none> )]'
		)]
	)]



/*
================================================================================
== FUNCTIONS ===================================================================

They'll all make it down here eventually.

--------------------------------------------------------------------------------
-- Function: Is Faction? -------------------------------------------------------

A user-defined function.

0: dbref/name
1: faction name (partial match) or dbref

returns: 1 or 0

*/

&f.isfaction? [v( d.afo )]=
	if( isstaff( %@ ), 
		t( 
			match( 
				get( [pmatch( %0 )]/_faction-member ), 
				?![locate( %!, %1, i )], 
				| 
			)
		), 
		#-1 Staff Only 
	)


/*
--------------------------------------------------------------------------------
-- Filter: See Faction ---------------------------------------------------------

Can see a faction if one of the following:
	The faction is not dark
	Player is Staff
	Player passes 'view permissions' ( usually 'is faction member' )

Called with:
	filter( fil.see-faction, <dbref list>, , , %# )
	u( fil.see-faction, <dbref>, %# )

*/

&fil.see-faction [v( d.afo )]=or( 
		orflags( %0, !D ), 
		isstaff( %1 ), 
		u( f.check-view-permissions, %0, %1 )
	)


/*
--------------------------------------------------------------------------------
-- Function: Check View Permissions --------------------------------------------

( Known as the switch /permission )

If the person passes this test, they can see the faction even if it's dark.

Looks for: &view-permission: <list>|<of>|<locks>
	faction:<faction dbref>
	attribute:<attr name>[:<value>]

Note: If 'Faction:!<this faction>', then do not show it to people even if they're on the faction, UNLESS they are a faction-head.

"Check View Permissions" must NOT evaluate code.

0: dbref of faction object
1: dbref of player
returns: 1 or 0

*/

&f.check-view-permissions [v( d.afo )]=
	localize( 
		or( 
// faction member can always see the faction, unless '!faction:<faction name>'
			and( 
				t( match( get( %1/_faction-member ), ?!%0, | )), 
				not( match( 
					setr( v, get( %0/d_view-permission )), !faction:[name( %0 )], |
				 ))
			 ), 
// faction head can always see the faction
			t( match( get( %1/_faction-member ), H!%0, | )), 
// if pass view access can always see the faction -- temp to new access setup
			u( #3233/f.access, %1, %qv )
		)
	)


/*
--------------------------------------------------------------------------------
-- Function: Faction Head? -----------------------------------------------------

Is this person a faction head or have the proper staff credentials?

0: target dbref
1: faction dbref
returns: 1 if yes, 0 if no or error

*/

&f.factionhead? [v( d.afo )]=
	or( isstaff( %0 ), t( match( get( %0/_faction-member ), H!%1, | )))


/*
--------------------------------------------------------------------------------
-- Function: Faction Name ------------------------------------------------------

Pretty up the faction name.

0: faction dbref

*/

&f.name.faction [v( d.afo )]=
	[name( %0 )]
	[if( hasattr( %0, d_type ), %b( [lcstr( get( %0/d_type ))] ))]
	[if( hasflag( %0, going ), %b<going> )]


/*
--------------------------------------------------------------------------------
-- Function: Sort Factions By Type ---------------------------------------------

0/1: Dbref of faction
Returns: List 
Usage:
	sortby( f.sortby.factions.type, <list of factions> )

*/

&f.sortby.factions.type [v( d.afo )]=comp( get( %0/d_type ), get( %1/d_type ))


/*
--------------------------------------------------------------------------------
-- Function: Player's Factions of Type -----------------------------------------

I'm not using filter() here for no particular reason than saving an attribute.

0: player dbref
1: type name (full)
returns: list of dbrefs of factions the player belongs to and match %1

*/

&f.player.factions-of-type [v( d.afo )]=
	setunion( 
		iter( 
			iter( get( %0/_faction-member ), rest( %i0, ! ), | ), 
			if( strmatch( get( %i0/d_type ), %1 ), %i0 )
		 ), 
	)


/*
--------------------------------------------------------------------------------
-- Function: Player's Factions of Type: Names ----------------------------------

This is slightly different than above because +sheet is returning '#-1 not found' for name( <null> ). Imagine that.

0: player dbref
1: type name ( full )
returns: list - of - names, or <null> if no match

ql: list

*/

&f.player.factions-of-type.names [v( d.afo )]=
	localize( 
		[setq( l, u( f.player.factions-of-type, %0, %1 ))]
		[if( t( %ql ), iter( %ql, name( %ql ), , %b-%b ))] 
	)


/*
=-=--=-==-=-=-

RANDOM THOUGHT:

think [setq( p, pmatch( kottyn ))][setunion( iter( iter( get( %qp/_faction-member ), rest( %i0, ! ), | ), get( %i0/d_type )), )]

I no longer know what this means.

-=-=-=-=-=-=-=
*/



/*
================================================================================
== faction/mail ================================================================

Mails everyone in a faction.

Check dark faction: u( fil.see-faction, %qf, %# )
Send-To List: u( f.faction.roster, %qf )

0: <faction name>=<subject>

qf: faction name
qs: subject

*/

&c.faction/mail [v( d.afo )]=
	[setq( f, num( trim( first( %0, = ))))]
	[setq( s, trim( rest( %0, = )))]
	[case( 0, 
		and( isdbref( %qf ), u( fil.see-faction, %qf, %# )), 
		u( .msg, faction, Faction could not be found ), 

		t( %qs ), u( .msg, faction, Subject was empty ), 

// >> ok -- trigger
		trigger( %!/tr.mail.faction, %#, %qf, %qs )
	)]


/*
--------------------------------------------------------------------------------
-- Trigger: faction/mail -------------------------------------------------------

Starts the mail.

0: dbref of sender
1: dbref of faction
2: subject of message

ql: list of targets

*/

&tr.mail.faction [v( d.afo )]=
	@eval [setq( l, iter( lattr( %1/member-* ), extract( %i0, 2, 1, - )))]; 
	@force %0=
	{
		@mail %ql=[name( %1 )]: %2; 
		think [ansi( h, <faction>, n, 
			%bContinue writing your faction mail as you normally would 
			with @mail. 
		)]
	}



/*
================================================================================
== faction/fix =================================================================

If someone was deleted from the server but never removed from the faction, 
fix will remove them from the list.

0: faction name

qf: faction dbref
qb: bad dbrefs
qc: character being investigated

*/

&c.faction/fix [v( d.afo )]=
	[setq( f, num( %0 ))]
	[case( 0, 
		isdbref( %qf ), u( .msg, faction, Faction could not be found ), 

		u( f.factionhead?, %#, %qf ), 
		u( .msg, faction, You are not a faction head for this faction ), 

// >> ok 
// .. store bad dbrefs -- also could have used filter() here, also lazy
		[setq( b, 
			iter( 
				lattr( %qf/member-* ), 
				[setq( c, extract( %i0, 2, 1, - ))]
// .. .. when bad, return dbref and unset 'member-...'
				[if( 
					not( match( get( %qc/_faction-member ), ?!%qf, | )), 
					%qc
					[set( %qf, %i0: )]
				)]
			)
		)]
// .. report
		[header( faction/fix [name( %qf )] )]%r
		[if( t( %qb ), 
			iter( %qb, %b [name( %i0 )] ( %i0 ): Removed, , %r ), 
			%b All good! No mismatched members.
		)]%r
		[footer( [words( %qb ) fixed] )]
	)]



/*
================================================================================
== faction/permission ==========================================================

Sets the View Lock for a specific channel, allowing someone not part of a dark faction to see it.

	faction/permission <faction>=<list|of|stuff>

--

qf: faction
qp: permissions

qd: faction's dbref
qs: stuff to set for permissions ( filtered )
qe: error permissions

qt: 'try' to set, check for errors

*/

&c.faction/permission [v( d.afo )]=
	[setq( f, first( %0, = ))]
	[setq( p, rest( %0, = ))]
	[setq( s, filter( fil.view-permissions, %qp, |, | ))]
	[setq( e, setdiff( %qp, %qs, |, | ))]

	[case( 0, 
		isstaff( %# ), 
		u( .msg, faction/permission, Staff only ), 

		t( setr( d, locate( %!, %qf, i ))), 
		u( .msg, faction/permission, Faction not found ), 

// %qp set, but %qs not: error. ( otherwise, clear is ok )
		or( t( words( %qs )), not( words( %qp ))), 
		u( .msg, faction/permission, No valid permissions entered ), 

// valid, but report errors anyway
		[setq( t, set( %qd, d_view-permission:%qs ))]
		[u( .msg, faction/permission, 
			[name( %qd )]: 
			[if( t( %qt ), ansi( r, Could Not Set ), Set: %qs )]
			[if( t( %qe ), 
				%, with some errors: %r
				[iter( %qe, %b %b invalid: %i0, |, %r )]
			)]
		)]
	)]


/*
--------------------------------------------------------------------------------
-- FILTER: View Permission -----------------------------------------------------

Check for basic validity on the faction view permissions.

*/

&fil.view-permissions [v( d.afo )]=
	case( first( %0, : ), 
		faction, t( strlen( rest( %0, : ))), 
		attribute, valid( attrname, elements( %0, 2, : ))
	)



/*
================================================================================
== Help: Faction ===============================================================

--------------------------------------------------------------------------------
-- Raw Text --------------------------------------------------------------------

Including some not-yet-included bits.

HELP_FACTION:

Character Groups & Factions

-------------------------

The faction commands allows staff and characters who are set up as faction 
heads to modify and maintain factions. You may use faction and factions 
interchangably for all commands.

Factions may be set "dark" by staff, hidden to those not in that faction.

GENERAL FACTION COMMANDS

faction
faction/list 
	Displays a list of all factions.

faction <faction name> 
	Lists information about the given faction. Repeated uses may appear
	to list the faction in different orders, but members are always
	listed by rank. Players marked with a > are faction heads.

fwho[/all] <faction name>
	Lists people on that faction who are online, or all members of that
	faction. Players marked with a > are faction heads.
	This is aliased to faction/who and faction/whoall

faction/mail <faction name>=<subject> 
	@mail a faction. It just sets up an @mail with the 'To' list filled
	in. If @mail complains about the list, the faction head should use 
	'faction/fix' for that faction. 

-------------------------

FACTION HEAD COMMANDS

If a faction does not have a faction head, these commands may be used by staff.

faction/information <faction name>[=<text>]
	Allows you to set a short bit of information for the +roster display.
	<text> should contain this information.

faction/add <character name>=<faction name>
	Allows a faction head to add a person to the +roster list with the
	option of giving the person a rank.

faction/remove <character name>=<faction name>
	Allows a faction head to remove a person from the +roster list.

-------------------------

MORE FACTION HEAD COMMANDS

faction/rank <character name>=<faction name>[/<rank>]
	The second use of faction/rank. Changes ( or gives ) the rank of
	<rank> to the character. If <rank> is not passed, it is cleared.

faction/title <character name>=<faction name>[/<title>]
	Like the second use of 'faction/rank', allows the change of any
	character's public title/position information for that faction.
	If <title> is not passed, it is cleared.

faction/fix <faction name> 
	Removes all junk entries and non-members from the roster. Use if
	faction/mail becomes broken for your faction.

-------------------------

CREDITS

The faction system was ported from AetherMUX, many long years ago. It was probably originally coded by Seth and updated by several people as needed.

-------------------------

Staff Faction Commands

-------------------------

These commands are those staff may use to maintain factions.

Factions must be:
	- Notable, IC
	- Game Relevant
	- Be a motley, pack, agency, or contain at least four people

faction/create <faction name>[=<faction head>]
	Allows a wizard to add a new faction to the database. Make sure
	<faction name> is the full name of the faction as you would want
	it displayed. The optional <faction head> is the name of the first
	faction head for that faction.

faction/destroy <faction name>
	Removes the faction from the game. Run 'faction/fix' first.

faction/undestroy <faction name>
	Saves that faction from distruction.

faction/addhead <faction name>=<character name> 
	Allows one to add a faction head to the faction. 

faction/removehead <faction name>=<character name> 
	Allows one to remove a faction head. A faction with no faction heads
	must be maintained by staff.

faction/[!]dark <faction name>
	Sets a faction dark (hidden) or sets it undark ( public )

faction/type <faction name>\[=<type>]
	Sets or removes a type for that faction. Useful for classifying, use 
	sparingly.

faction/permission <faction name>[=<list|of|items>]
	Determines whether or not someone is allowed to see a dark faction without 
	belonging to it. Items are:
	
	faction:<faction name>  - viewer belongs to <faction name>
	attribute:<attribute_name>  - viewer has <attribute_name>
	attribute:<attribute_name>:<value> - attribute is a specific value

isfaction?( <player>, <faction name> )
	Returns '1' (true) if <player> belongs to <faction name>.

(A step-by-step guide to creating factions is on the next page.)

See Also: +help factions

-------------------------

CREATING FACTIONS

faction/create <faction name>=<faction head>
	Include "faction head" wherever possible as they are ooc
	administrators.

faction/info <faction>=<useful blurb>

faction/add <character name>=<faction name>
	Faction heads can do these, too.

Optional:
	faction/type <faction name>=<type name>
	Use this only for "pack" and "motley".

	faction/dark <faction name>
	Use this only if faction is a secret group.

Notes:
* Factions are objects, so you can change the faction name by
  changing the object name.
* Dark factions are dark objects.
* Faction Heads are OOC adminitrators of faction objects.

*/